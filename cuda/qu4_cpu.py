# -*- coding: utf-8 -*-
"""qu4_cuda.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ymMfv49XEUqKRns5KqZfaFgFve0irpB
"""

import torch as tc
import numpy as np
import torch.nn as nn
import matplotlib.pyplot as plt

class Qu4(nn.Module):
    loss_history = []

    def __init__(self):
        super(Qu4, self).__init__()

        # Define the parameters of your model here.
        self.params = nn.Parameter(tc.randn(139,dtype=tc.float64),requires_grad=True)

        self.swap = self.generate_swapmatrix()
        v = 0.37
        self.object_list = self.obj_list(v)


    def generate_state(self,a,b,c):
        a = tc.unsqueeze(a,0)
        b = tc.unsqueeze(b,0)
        c = tc.unsqueeze(c,0)



        psi01 = tc.cat((tc.cos(a),tc.zeros(4,device=self.params.device),tc.sin(a) * tc.cos(b),tc.zeros(4,device=self.params.device),tc.sin(a) * tc.sin(b) * tc.cos(c), tc.zeros(4,device=self.params.device), tc.sin(a) * tc.sin(b) * tc.sin(c) ))
        psi23 = psi01
        psi45 = psi01

        psi0123 = tc.kron(psi01,psi23)
        psi012345 = tc.kron(psi0123,psi45)

        return psi012345

    def generate_swapmatrix(self):

        s = tc.tensor([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
                     [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                     [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                     [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]

        ], dtype=tc.float64,device=self.params.device)

        s01 = tc.kron(s,tc.eye(4**4,device=self.params.device))

        s12_ = tc.kron(tc.eye(4,device=self.params.device),s)
        s12 = tc.kron(s12_,tc.eye(4**3,device=self.params.device))

        s23_ = tc.kron(tc.eye(4**2,device=self.params.device),s)
        s23 = tc.kron(s23_,tc.eye(4**2,device=self.params.device))

        s34_ = tc.kron(tc.eye(4**3,device=self.params.device),s)
        s34 = tc.kron(s34_,tc.eye(4,device=self.params.device))

        s45 = tc.kron(tc.eye(4**4,device=self.params.device),s)

        swap_cyclic = tc.einsum('ab,bc,cd,de,ef->af', s45, s34, s23, s12, s01)

        return swap_cyclic

    def swap_cyclic(self,state):
        return tc.matmul(self.swap,state)

    def density_matrix(self,state):
        return tc.outer(state,state.conj())

    def povm(self,density,m1,m2,m3):
        ma = tc.kron(tc.kron(m1,m2),m3)
        mb = tc.matmul(density,ma)
        return tc.trace(mb)

    def generate_POVM(self,v):


        params = v
        A = tc.zeros((16, 16), dtype=tc.float64,device=self.params.device)

        D_i = params[:16]
        # parameterize the diagonal matrix D
        D = tc.diag(tc.sigmoid(D_i))

        # parameterize the skew-symmetric matrix A
        idx = tc.triu_indices(16, 16, offset=1)  # indices for the upper triangular part excluding the diagonal
        A[idx[0], idx[1]] = params[16:]
        A = A - A.T  # to make A skew-symmetric

        # generate an orthogonal matrix O using the skew-symmetric matrix
        M = tc.eye(16,device=self.params.device) + A
        U = tc.mm(M, tc.inverse(tc.eye(16,device=self.params.device) - A))

        m1 = tc.mm(tc.mm(U, D), U.t())

        return m1

    def povm_result(self,rou,m1,m1_,m2,m2_,m3,m3_):
        povm_000 = self.povm(rou,m1,m2,m3)
        povm_001 = self.povm(rou,m1,m2,m3_)
        povm_010 = self.povm(rou,m1,m2_,m3)
        povm_011 = self.povm(rou,m1,m2_,m3_)
        povm_100 = self.povm(rou,m1_,m2,m3)
        povm_101 = self.povm(rou,m1_,m2,m3_)
        povm_110 = self.povm(rou,m1_,m2_,m3)
        povm_111 = self.povm(rou,m1_,m2_,m3_)

        result_list = [povm_000,povm_001,povm_010,povm_011,povm_100,povm_101,povm_110,povm_111]

        return result_list

    def obj_list(self,v):

        p = [0]*8
        for i in range (8):
            if i == 0:
                p[i] = (1+3*v)/8
            elif i == 7:
                p[i] = (1+3*v)/8
            else:
                p[i] = (1-v)/8
        return p

    def obj_fun(self,list_obj,list_m):
        kl= 0
        for i in range(8):
            kl += list_obj[i] * tc.log(list_obj[i]/list_m[i])
        return kl

    def loss_KL(self):

        state = self.generate_state(self.params[0],self.params[1],self.params[2])

        state_swaped = self.swap_cyclic(state)
        rou = self.density_matrix(state_swaped)

        m1 = self.generate_POVM(self.params[3:139])
        m1_ = tc.eye(16,device=self.params.device) - m1
        m2 = m1
        m2_ = tc.eye(16,device=self.params.device) - m2
        m3 = m1
        m3_ = tc.eye(16,device=self.params.device) - m3

        result_list = self.povm_result(rou,m1,m1_,m2,m2_,m3,m3_)


        y = self.obj_fun(self.object_list,result_list)

        return y

    def optimize(self,optimizer, epochs=20000):

        for i in range(epochs):
            optimizer.zero_grad()  # clear previous gradients
            loss = self.loss_KL()  # compute the loss
            if loss.item()<=1e-12:
                print('Bravo!!!!!!!!!!!!!!!!!!!')

                tc.save(self.params,'qu4_cpu_0.37.pt')



            loss.backward()  # compute updates for each parameter
            optimizer.step()  # make the updates for each parameter

            # Record the loss
            Qu4.loss_history.append(loss.item())
            if i%1 == 0:
                print(i,loss)


    def draw(self):
        plt.figure(figsize=(10, 6))
        plt.plot(Qu4.loss_history)
        plt.yscale('log')
        plt.xlabel('Epoch')
        plt.ylabel('Loss')
        plt.title('Loss over time')
        plt.savefig('plot.png')

    def show_state(self,a,b,c):
        a = tc.unsqueeze(a,0)
        b = tc.unsqueeze(b,0)
        c = tc.unsqueeze(c,0)



        psi01 = tc.cat((tc.cos(a),tc.zeros(4,device=self.params.device),tc.sin(a) * tc.cos(b),tc.zeros(4,device=self.params.device),tc.sin(a) * tc.sin(b) * tc.cos(c), tc.zeros(4,device=self.params.device), tc.sin(a) * tc.sin(b) * tc.sin(c) ))
        return psi01

model = Qu4()


optimizer = tc.optim.Adam(model.parameters(), lr=0.01)  # Use Adam for optimization.

model.optimize(optimizer)

model.draw()
psi01 = model.show_state(model.params[0],model.params[1],model.params[2])
print(psi01)







# Create a list to hold the loss values





# After training, plot the loss history



print(model.params)

state = model.generate_state(model.params[0],model.params[1],model.params[2])

state_swaped = model.swap_cyclic(state)
rou = model.density_matrix(state_swaped)

m1 = model.generate_POVM(model.params[3:139])
m1_ = tc.eye(16,device=model.params.device) - m1
m2 = m1
m2_ = tc.eye(16,device=model.params.device) - m2
m3 = m1
m3_ = tc.eye(16,device=model.params.device) - m3

result_list = model.povm_result(rou,m1,m1_,m2,m2_,m3,m3_)


print(result_list)









#p =  {'para': self.params, 'psi01': psi01, 'result':result_list, 'm1':m1}


#tc.save(p,'ququart_v0.396_arrox.pt')





